# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Landlab Algorithm Provider
                                 A QGIS plugin
 Earth Surface Dynamics modeling algorithms
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-07-25
        copyright            : (C) 2025 by Lucas Amion
        email                : lamion@dcc.uchile.cl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Lucas Amion'
__date__ = '2025-07-25'
__copyright__ = '(C) 2025 by Lucas Amion'


from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessingAlgorithm,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterRasterDestination,
                       QgsProcessingException,
                       QgsProcessingParameterNumber,
                       QgsRasterLayer,
                       QgsProject)

import numpy as np
from osgeo import gdal
from landlab import RasterModelGrid
from landlab.components import FlowAccumulator, StreamPowerEroder as LandlabStreamPowerEroder


class StreamPowerEroder(QgsProcessingAlgorithm):
  """
  This algorithm applies stream power erosion to a raster layer.
  
  It takes a raster layer (typically a digital elevation model) and
  applies stream power erosion calculations to simulate the erosional
  processes that shape landscapes over time.

  All Processing algorithms should extend the QgsProcessingAlgorithm
  class.
  """

  # Constants used to refer to parameters and outputs. They will be
  # used when calling the algorithm from another algorithm, or when
  # calling from the QGIS console.

  OUTPUT = 'OUTPUT'
  INPUT = 'INPUT'
  K_SP = 'K_SP'
  DT = 'DT'

  def initAlgorithm(self, config):
    """
    Here we define the inputs and output of the algorithm, along
    with some other properties.
    """

    # We add the input raster layer.
    self.addParameter(
      QgsProcessingParameterRasterLayer(
        self.INPUT,
        self.tr('Input raster layer')
      )
    )

    # Add parameter for erosion constant K_sp
    self.addParameter(
      QgsProcessingParameterNumber(
        self.K_SP,
        self.tr('Erosion constant (K_sp)'),
        type=QgsProcessingParameterNumber.Double,
        defaultValue=1.0,
        minValue=0.0
      )
    )

    # Add parameter for time step dt
    self.addParameter(
      QgsProcessingParameterNumber(
        self.DT,
        self.tr('Time step (dt)'),
        type=QgsProcessingParameterNumber.Double,
        defaultValue=1.0,
        minValue=0.0
      )
    )

    # We add a raster destination in which to store our processed raster
    # (this usually takes the form of a newly created raster layer when the
    # algorithm is run in QGIS).
    self.addParameter(
      QgsProcessingParameterRasterDestination(
        self.OUTPUT,
        self.tr('Output raster layer')
      )
    )

  def processAlgorithm(self, parameters, context, feedback):
    """
    Here is where the processing itself takes place.
    """

    # Retrieve the input raster layer
    input_layer = self.parameterAsRasterLayer(parameters, self.INPUT, context)
    
    if input_layer is None:
      raise QgsProcessingException(self.tr('Input raster layer is not valid'))

    # Get parameters
    k_sp = self.parameterAsDouble(parameters, self.K_SP, context)
    dt = self.parameterAsDouble(parameters, self.DT, context)
    output_path = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)

    feedback.pushInfo(self.tr(f'Processing raster: {input_layer.source()}'))
    feedback.pushInfo(self.tr(f'K_sp: {k_sp}, dt: {dt}'))
    feedback.pushInfo(self.tr(f'Output will be saved to: {output_path}'))
    
    # Read raster data
    provider = input_layer.dataProvider()
    extent = provider.extent()
    width = provider.xSize()
    height = provider.ySize()
    
    # Calculate pixel size (assuming square pixels)
    dx = extent.width() / width
    dy = extent.height() / height
    
    feedback.pushInfo(self.tr(f'Raster dimensions: {width}x{height}, pixel size: {dx:.2f}x{dy:.2f}'))
    
    # Read the raster data as numpy array
    block = provider.block(1, extent, width, height)
    
    # Convert to numpy array
    elevation_data = np.zeros((height, width), dtype=np.float64)
    for row in range(height):
      for col in range(width):
        elevation_data[row, col] = block.value(row, col)
    
    feedback.setProgress(20)
    
    # Create Landlab RasterModelGrid
    # Note: Landlab expects (rows, cols) and uses node spacing
    mg = RasterModelGrid((height, width), xy_spacing=(dx, dy))
    
    # Add elevation field to the grid
    mg.add_field("topographic__elevation", elevation_data.flatten(), at="node")
    
    feedback.setProgress(40)
    
    # Initialize flow accumulator and stream power eroder
    fr = FlowAccumulator(mg, flow_director="D8")
    sp = LandlabStreamPowerEroder(mg, K_sp=k_sp)
    
    feedback.pushInfo(self.tr('Running flow accumulation...'))
    fr.run_one_step()
    
    feedback.setProgress(60)
    
    feedback.pushInfo(self.tr('Running stream power erosion...'))
    sp.run_one_step(dt=dt)
    
    feedback.setProgress(80)
    
    # Get the modified elevation data
    modified_elevation = mg.at_node["topographic__elevation"].reshape((height, width))
    
    # Create output raster
    # Create a new GDAL dataset
    driver = gdal.GetDriverByName('GTiff')
    output_dataset = driver.Create(output_path, width, height, 1, gdal.GDT_Float64)
    
    # Set geotransform and projection
    geotransform = [
      extent.xMinimum(),  # top-left x
      dx,                 # pixel width
      0,                  # rotation (0 for north-up images)
      extent.yMaximum(),  # top-left y
      0,                  # rotation (0 for north-up images)
      -dy                 # pixel height (negative for north-up images)
    ]
    output_dataset.SetGeoTransform(geotransform)
    output_dataset.SetProjection(input_layer.crs().toWkt())
    
    # Write the data
    band = output_dataset.GetRasterBand(1)
    band.WriteArray(modified_elevation)
    band.SetNoDataValue(provider.sourceNoDataValue(1))
    
    # Close the dataset
    output_dataset = None
    
    # Create a QgsRasterLayer from the output file
    output_layer = QgsRasterLayer(output_path, "Stream Power Eroded DEM")
    
    # Copy the renderer (color scheme) from the input layer to the output layer
    if input_layer.renderer():
      # Clone the renderer from the input layer
      renderer_clone = input_layer.renderer().clone()
      output_layer.setRenderer(renderer_clone)
      
      # Trigger a repaint to apply the new renderer
      output_layer.triggerRepaint()
      
      feedback.pushInfo(self.tr('Applied color scheme from input layer to output layer'))
    
    # Add the layer to the project to make the color scheme visible
    QgsProject.instance().addMapLayer(output_layer)
    
    feedback.setProgress(100)

    # Return the output path
    return {self.OUTPUT: output_path}

  def name(self):
    """
    Returns the algorithm name, used for identifying the algorithm. This
    string should be fixed for the algorithm, and must not be localised.
    The name should be unique within each provider. Names should contain
    lowercase alphanumeric characters only and no spaces or other
    formatting characters.
    """
    return 'stream_power_eroder'

  def displayName(self):
    """
    Returns the translated algorithm name, which should be used for any
    user-visible display of the algorithm name.
    """
    return 'Stream Power Eroder'


  def group(self):
    """
    Returns the name of the group this algorithm belongs to. This string
    should be localised.
    """
    return self.tr('Erosion')

  def groupId(self):
    """
    Returns the unique ID of the group this algorithm belongs to. This
    string should be fixed for the algorithm, and must not be localised.
    The group id should be unique within each provider. Group id should
    contain lowercase alphanumeric characters only and no spaces or other
    formatting characters.
    """
    return 'erosion'
  
  def icon(self):
    """
    Returns the icon for the algorithm, which is used in the Processing
    toolbox.
    """
    return QIcon(":/plugins/landlab_algorithm_provider/img/icon.png")

  def tr(self, string):
    return QCoreApplication.translate('Processing', string)

  def createInstance(self):
    return StreamPowerEroder()

  def shortHelpString(self):
    """
    Returns a localised short helper string for the algorithm. This string
    should provide a basic description about what the algorithm does and the
    parameters and outputs associated with it.
    """
    return self.tr("""
    This algorithm applies stream power erosion to a topographic surface.

    The <b>Stream Power Eroder</b> component simulates erosional processes that shape landscapes over time using the stream power law. It calculates erosion rates based on drainage area, slope, and user-defined parameters to model landscape evolution.

    <b>Parameters:</b>
      <b>- Input raster layer:</b> Digital elevation model to process
      <b>- Erosion constant (K_sp):</b> Stream power erosion coefficient that controls erosion rate
      <b>- Time step (dt):</b> Duration of erosion simulation in model time units

    <b>Output:</b>
      <b>- Eroded DEM:</b> Raster layer showing the topography after stream power erosion

    <b>Note:</b> This algorithm requires flow accumulation to be calculated internally using D8 flow routing before applying erosion.
    """)
