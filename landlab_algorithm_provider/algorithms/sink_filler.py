# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Landlab Algorithm Provider
                                 A QGIS plugin
 Earth Surface Dynamics modeling algorithms
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-07-25
        copyright            : (C) 2025 by Lucas Amion
        email                : lamion@dcc.uchile.cl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Lucas Amion'
__date__ = '2025-07-25'
__copyright__ = '(C) 2025 by Lucas Amion'


from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessingAlgorithm,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterRasterDestination,
                       QgsProcessingException,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterBoolean,
                       QgsRasterLayer,
                       QgsProject)

import numpy as np
from osgeo import gdal
from landlab import RasterModelGrid
from landlab.components import SinkFiller as LandlabSinkFiller


class SinkFiller(QgsProcessingAlgorithm):
  """
  This algorithm fills depressions (sinks) in a topographic surface.
  
  It takes a raster layer (typically a digital elevation model) and
  identifies depressions in the topographic surface, then fills them.
  No attempt is made to conserve sediment mass. User may specify whether
  the holes should be filled to flat, or with a gradient downwards towards
  the depression outlet.

  All Processing algorithms should extend the QgsProcessingAlgorithm
  class.
  """

  # Constants used to refer to parameters and outputs. They will be
  # used when calling the algorithm from another algorithm, or when
  # calling from the QGIS console.

  OUTPUT = 'OUTPUT'
  INPUT = 'INPUT'
  ROUTING = 'ROUTING'
  APPLY_SLOPE = 'APPLY_SLOPE'
  FILL_SLOPE = 'FILL_SLOPE'

  def initAlgorithm(self, config):
    """
    Here we define the inputs and output of the algorithm, along
    with some other properties.
    """

    # We add the input raster layer.
    self.addParameter(
      QgsProcessingParameterRasterLayer(
        self.INPUT,
        self.tr('Input raster layer')
      )
    )

    # Add parameter for routing method
    self.addParameter(
      QgsProcessingParameterEnum(
        self.ROUTING,
        self.tr('Routing method'),
        options=['D8', 'D4'],
        defaultValue=0  # D8 is default
      )
    )

    # Add parameter for apply slope
    self.addParameter(
      QgsProcessingParameterBoolean(
        self.APPLY_SLOPE,
        self.tr('Apply slope to filled areas'),
        defaultValue=False
      )
    )

    # Add parameter for fill slope
    self.addParameter(
      QgsProcessingParameterNumber(
        self.FILL_SLOPE,
        self.tr('Fill slope (m/m)'),
        type=QgsProcessingParameterNumber.Double,
        defaultValue=1e-05,
        minValue=0.0
      )
    )

    # We add a raster destination in which to store our processed raster
    # (this usually takes the form of a newly created raster layer when the
    # algorithm is run in QGIS).
    self.addParameter(
      QgsProcessingParameterRasterDestination(
        self.OUTPUT,
        self.tr('Output raster layer')
      )
    )

  def processAlgorithm(self, parameters, context, feedback):
    """
    Here is where the processing itself takes place.
    """

    # Retrieve the input raster layer
    input_layer = self.parameterAsRasterLayer(parameters, self.INPUT, context)
    
    if input_layer is None:
      raise QgsProcessingException(self.tr('Input raster layer is not valid'))

    # Get parameters
    routing_index = self.parameterAsEnum(parameters, self.ROUTING, context)
    routing_methods = ['D8', 'D4']
    routing = routing_methods[routing_index]
    
    apply_slope = self.parameterAsBool(parameters, self.APPLY_SLOPE, context)
    fill_slope = self.parameterAsDouble(parameters, self.FILL_SLOPE, context)
    output_path = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)

    feedback.pushInfo(self.tr(f'Processing raster: {input_layer.source()}'))
    feedback.pushInfo(self.tr(f'Routing: {routing}, Apply slope: {apply_slope}, Fill slope: {fill_slope}'))
    feedback.pushInfo(self.tr(f'Output will be saved to: {output_path}'))
    
    # Read raster data
    provider = input_layer.dataProvider()
    extent = provider.extent()
    width = provider.xSize()
    height = provider.ySize()
    
    # Calculate pixel size (assuming square pixels)
    dx = extent.width() / width
    dy = extent.height() / height
    
    feedback.pushInfo(self.tr(f'Raster dimensions: {width}x{height}, pixel size: {dx:.2f}x{dy:.2f}'))
    
    # Read the raster data as numpy array
    block = provider.block(1, extent, width, height)
    
    # Convert to numpy array
    elevation_data = np.zeros((height, width), dtype=np.float64)
    for row in range(height):
      for col in range(width):
        elevation_data[row, col] = block.value(row, col)
    
    feedback.setProgress(20)
    
    # Create Landlab RasterModelGrid
    # Note: Landlab expects (rows, cols) and uses node spacing
    mg = RasterModelGrid((height, width), xy_spacing=(dx, dy))
    
    # Add elevation field to the grid
    mg.add_field("topographic__elevation", elevation_data.flatten(), at="node")
    
    feedback.setProgress(40)
    
    # Initialize sink filler
    sf = LandlabSinkFiller(mg, routing=routing, apply_slope=apply_slope, fill_slope=fill_slope)
    
    feedback.pushInfo(self.tr('Running sink filling...'))
    sf.run_one_step()
    
    feedback.setProgress(80)
    
    # Get the modified elevation data
    modified_elevation = mg.at_node["topographic__elevation"].reshape((height, width))
    
    # Create output raster
    # Create a new GDAL dataset
    driver = gdal.GetDriverByName('GTiff')
    output_dataset = driver.Create(output_path, width, height, 1, gdal.GDT_Float64)
    
    # Set geotransform and projection
    geotransform = [
      extent.xMinimum(),  # top-left x
      dx,                 # pixel width
      0,                  # rotation (0 for north-up images)
      extent.yMaximum(),  # top-left y
      0,                  # rotation (0 for north-up images)
      -dy                 # pixel height (negative for north-up images)
    ]
    output_dataset.SetGeoTransform(geotransform)
    output_dataset.SetProjection(input_layer.crs().toWkt())
    
    # Write the data
    band = output_dataset.GetRasterBand(1)
    band.WriteArray(modified_elevation)
    band.SetNoDataValue(provider.sourceNoDataValue(1))
    
    # Close the dataset
    output_dataset = None
    
    # Create a QgsRasterLayer from the output file
    output_layer = QgsRasterLayer(output_path, "Sink-Filled DEM")
    
    # Copy the renderer (color scheme) from the input layer to the output layer
    if input_layer.renderer():
      # Clone the renderer from the input layer
      renderer_clone = input_layer.renderer().clone()
      output_layer.setRenderer(renderer_clone)
      
      # Trigger a repaint to apply the new renderer
      output_layer.triggerRepaint()
      
      feedback.pushInfo(self.tr('Applied color scheme from input layer to output layer'))
    
    # Add the layer to the project to make the color scheme visible
    QgsProject.instance().addMapLayer(output_layer)
    
    feedback.setProgress(100)

    # Return the output path
    return {self.OUTPUT: output_path}

  def name(self):
    """
    Returns the algorithm name, used for identifying the algorithm. This
    string should be fixed for the algorithm, and must not be localised.
    The name should be unique within each provider. Names should contain
    lowercase alphanumeric characters only and no spaces or other
    formatting characters.
    """
    return 'sink_filler'

  def displayName(self):
    """
    Returns the translated algorithm name, which should be used for any
    user-visible display of the algorithm name.
    """
    return 'Sink Filler'

  def group(self):
    """
    Returns the name of the group this algorithm belongs to. This string
    should be localised.
    """
    return self.tr('Preprocessing')

  def groupId(self):
    """
    Returns the unique ID of the group this algorithm belongs to. This
    string should be fixed for the algorithm, and must not be localised.
    The group id should be unique within each provider. Group id should
    contain lowercase alphaneric characters only and no spaces or other
    formatting characters.
    """
    return 'preprocessing'
  
  def icon(self):
    """
    Returns the icon for the algorithm, which is used in the Processing
    toolbox.
    """
    return QIcon(":/plugins/landlab_algorithm_provider/img/icon.png")

  def tr(self, string):
    return QCoreApplication.translate('Processing', string)

  def createInstance(self):
    return SinkFiller()

  def shortHelpString(self):
    """
    Returns a localised short helper string for the algorithm. This string
    should provide a basic description about what the algorithm does and the
    parameters and outputs associated with it.
    """
    return self.tr("""
    This algorithm identifies depressions in a topographic surface and fills them.

    The <b>SinkFiller</b> component fills depressions (sinks) in digital elevation models. No attempt is made to conserve sediment mass. You can specify whether the holes should be filled to flat, or with a gradient downwards towards the depression outlet.

    <b>Parameters:</b>
      <b>- Input raster layer:</b> Digital elevation model to process
      <b>- Routing method:</b> D8 (8-direction) or D4 (4-direction) flow routing
      <b>- Apply slope:</b> If checked, applies a slope to filled areas for flow routing
      <b>- Fill slope:</b> The slope applied to filled areas (only used if Apply slope is checked)

    <b>Output:</b>
      <b>- Sink-filled DEM:</b> Raster layer with depressions removed
    """)
